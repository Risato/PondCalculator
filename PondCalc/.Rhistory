})
# Run the application
shinyApp(ui = ui, server = server)
library(readxl)
library(dplyr)
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
voltable <- read_excel("C:/Users/RisatoMob/Desktop/LDSF_Vol_Table.xlsx")
voltable
# Remove USFS Control Data
data<- filter(treedata, comp != "Fscontrol" , comp != "FScontrol")
data
# Calculate BA/Acre per tree
data$BA = data$dbh^2*0.005454
data$BAperAcre = data$BA*10
Current = aggregate(data$BAperAcre, list(plot = data$plot, comp = data$comp), FUN =sum)
colnames(Current)[colnames(Current) == 'x'] <- 'CurrentBA'
Current = aggregate(CurrentBA ~ comp, Current, mean)
#Summarize total BA removed
table(treedata$harvest)
cut = filter(data, harvest == "Y")
Removed = aggregate(cut$BAperAcre, list(plot = cut$plot, comp = cut$comp), FUN =sum)
colnames(Removed)[colnames(Removed) == 'x'] <- 'RemovedBA'
Removed = aggregate(RemovedBA ~ comp, Removed, mean)
# Summarize total Ba remaining
keep = filter(data, is.na(harvest))
Residual = aggregate(keep$BAperAcre, list(plot = keep$plot, comp = keep$comp), FUN =sum)
colnames(Residual)[colnames(Residual) == 'x'] <- 'ResidualBA'
Residual = aggregate(ResidualBA ~ comp, Residual, mean)
# Combine summaries
temp <- merge(Residual, Removed, "comp", all = TRUE)
total <- merge(Current, temp, "comp", all = TRUE)
total
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
library(readxl)
library(dplyr)
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
# Import LDSF Data
treedata <- read_excel("C:\Users\RisatoMob\Desktop\Dropbox\Silviculture for Climate Change Study Data\LaTour Data/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
library(readxl)
library(dplyr)
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
voltable <- read_excel("C:/Users/RisatoMob/Desktop/LDSF_Vol_Table.xlsx")
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
voltable <- read_excel("C:/Users/RisatoMob/Desktop/LDSF_Vol_Table.xlsx")
voltable <- read_excel("C:/Users/RisatoMob/Desktop/LSDF_Vol_Table.xlsx")
voltable
# Remove USFS Control Data
data<- filter(treedata, comp != "Fscontrol" , comp != "FScontrol")
data
# Calculate BA/Acre per tree
data$BA = data$dbh^2*0.005454
data$BAperAcre = data$BA*10
Current = aggregate(data$BAperAcre, list(plot = data$plot, comp = data$comp), FUN =sum)
colnames(Current)[colnames(Current) == 'x'] <- 'CurrentBA'
Current = aggregate(CurrentBA ~ comp, Current, mean)
#Summarize total BA removed
table(treedata$harvest)
cut = filter(data, harvest == "Y")
Removed = aggregate(cut$BAperAcre, list(plot = cut$plot, comp = cut$comp), FUN =sum)
colnames(Removed)[colnames(Removed) == 'x'] <- 'RemovedBA'
Removed = aggregate(RemovedBA ~ comp, Removed, mean)
# Summarize total Ba remaining
keep = filter(data, is.na(harvest))
Residual = aggregate(keep$BAperAcre, list(plot = keep$plot, comp = keep$comp), FUN =sum)
colnames(Residual)[colnames(Residual) == 'x'] <- 'ResidualBA'
Residual = aggregate(ResidualBA ~ comp, Residual, mean)
# Combine summaries
temp <- merge(Residual, Removed, "comp", all = TRUE)
library(readxl)
library(dplyr)
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
voltable <- read_excel("C:/Users/RisatoMob/Desktop/LDSF_Vol_Table.xlsx")
voltable
# Remove USFS Control Data
data<- filter(treedata, comp != "Fscontrol" , comp != "FScontrol")
data
# Calculate BA/Acre per tree
data$BA = data$dbh^2*0.005454
data$BAperAcre = data$BA*10
Current = aggregate(data$BAperAcre, list(plot = data$plot, comp = data$comp), FUN =sum)
colnames(Current)[colnames(Current) == 'x'] <- 'CurrentBA'
Current = aggregate(CurrentBA ~ comp, Current, mean)
current
Current
data
data$dbh<8
data(data$dbh<8)
data[data$dbh<8]
data
data[data$dbh<=8]
data$dbh
source('C:/Users/RisatoMob/Desktop/Dropbox/Silviculture for Climate Change Study Data/LaTour Data/LDSF_Inventory.R', echo=TRUE)
data[data$dbh<=8.0]
data$dbh
data$dbh>8
data[data$dbh>8]
data(data$dbh<=8.0)
data(data$dbh)<=8
data[(data$dbh)<=8]
data$%dbh <- data[data$dbh>8]
data$DBH <- data[data$dbh>8]
data$DBH <- data[data$dbh>8]
library(readxl)
library(dplyr)
# Import LDSF Data
treedata <- read_excel("C:/Users/RisatoMob/Desktop/All_Plots_LaTour_Data_OLM_10.11.18.xlsx", sheet = "tree_inventory")
voltable <- read_excel("C:/Users/RisatoMob/Desktop/LDSF_Vol_Table.xlsx")
voltable
# Remove USFS Control Data
data<- filter(treedata, comp != "Fscontrol" , comp != "FScontrol")
data
# Calculate BA/Acre per tree
data$BA = data$dbh^2*0.005454
data$BAperAcre = data$BA*10
Current = aggregate(data$BAperAcre, list(plot = data$plot, comp = data$comp), FUN =sum)
colnames(Current)[colnames(Current) == 'x'] <- 'CurrentBA'
Current = aggregate(CurrentBA ~ comp, Current, mean)
Current
#Summarize total BA removed
table(treedata$harvest)
cut = filter(data, harvest == "Y")
Removed = aggregate(cut$BAperAcre, list(plot = cut$plot, comp = cut$comp), FUN =sum)
colnames(Removed)[colnames(Removed) == 'x'] <- 'RemovedBA'
Removed = aggregate(RemovedBA ~ comp, Removed, mean)
# Summarize total Ba remaining
keep = filter(data, is.na(harvest))
Residual = aggregate(keep$BAperAcre, list(plot = keep$plot, comp = keep$comp), FUN =sum)
colnames(Residual)[colnames(Residual) == 'x'] <- 'ResidualBA'
Residual = aggregate(ResidualBA ~ comp, Residual, mean)
# Combine summaries
temp <- merge(Residual, Removed, "comp", all = TRUE)
total <- merge(Current, temp, "comp", all = TRUE)
total
library("shiny")
library("ggplot2")
ui <- pageWithSidebar(
headerPanel("Tooltips in ggplot2 + shiny"),
sidebarPanel(
HTML("Tooltips are managed by combination of shiny+ggplot hover functionality",
"and css styles. By setting hover argument of 'plotOutput' we could access",
"hover data from the server side, as an ordinary input. Hover input is",
"a list with: position of cursor ON the image; domain - that is",
"values of variables at the plotting area edges; range - that is position",
"of plotting area edges in pixels relative to whole image element.",
"Additionally for ggplot used mappings are returned. </br>",
"To create tooltip first we need to identify position of the cursor",
"inside the image element. We do it by calculating distances from left and",
"top edge of image element from hover data. Then we create tooltip, in this",
"app it is 'wellPanel' with some info inside, and set 'position' property",
"to 'absolute' and set 'left' and 'top' properties to calculated values.",
"However, 'absolute' position is defined as relative to the nearest positioned",
"ancestor. Because we want to position tooltip inside the image, we need",
"to put both 'plotOutput' with image and 'uiOutput' with tooltip content",
"inside additional 'div' element with 'position' property set to 'relative'.",
"We don't set top, left etc. for this element, so the actual position of",
"the image doesn't change - it's edges are identical as previously, so",
"we can use 'div' (for positioning tooltip) as substitute for image. </br>"),
width = 3
),
mainPanel(
# this is an extra div used ONLY to create positioned ancestor for tooltip
# we don't change its position
div(
style = "position:relative",
plotOutput("scatterplot",
hover = hoverOpts("plot_hover", delay = 100, delayType = "debounce")),
uiOutput("hover_info")
),
width = 7
)
)
server <- function(input, output) {
output$scatterplot <- renderPlot({
ggplot(mtcars, aes(x = mpg, y = hp)) +
geom_point()
})
output$hover_info <- renderUI({
hover <- input$plot_hover
point <- nearPoints(mtcars, hover, threshold = 5, maxpoints = 1, addDist = TRUE)
if (nrow(point) == 0) return(NULL)
# calculate point position INSIDE the image as percent of total dimensions
# from left (horizontal) and from top (vertical)
left_pct <- (hover$x - hover$domain$left) / (hover$domain$right - hover$domain$left)
top_pct <- (hover$domain$top - hover$y) / (hover$domain$top - hover$domain$bottom)
# calculate distance from left and bottom side of the picture in pixels
left_px <- hover$range$left + left_pct * (hover$range$right - hover$range$left)
top_px <- hover$range$top + top_pct * (hover$range$bottom - hover$range$top)
# create style property fot tooltip
# background color is set so tooltip is a bit transparent
# z-index is set so we are sure are tooltip will be on top
style <- paste0("position:absolute; z-index:100; background-color: rgba(245, 245, 245, 0.85); ",
"left:", left_px + 2, "px; top:", top_px + 2, "px;")
# actual tooltip created as wellPanel
wellPanel(
style = style,
p(HTML(paste0("<b> Car: </b>", rownames(point), "<br/>",
"<b> mpg: </b>", point$mpg, "<br/>",
"<b> hp: </b>", point$hp, "<br/>",
"<b> Distance from left: </b>", left_px, "<b>, from top: </b>", top_px)))
)
})
}
runApp(list(ui = ui, server = server))
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
library(ggplot2)
library(plotly)
set.seed(1)
toy_df=data.frame("t"=c(seq(1,10),seq(1,10)),
"value"=c(runif(10,0,10),2*runif(10,0,10)),
"event"=c(rep("A",10),rep("B",10)))
# In order to create polygons like in geom_areas,
# two points on the x-axis must be added: one at t=1 and one at t=10
toy_df2 <- toy_df[NULL,]
for (k in unique(toy_df$event)) {
subdf <- subset(toy_df, toy_df$event==k)
nr <- nrow(subdf)
row1 <- subdf[1,]
row1$value <- 0
row2 <- subdf[nr,]
row2$value <- 0
toy_df2 <- rbind(toy_df2, row1, subdf, row2)
}
# Stack polygons
toy_df2$value[toy_df2$event=="A"] <- toy_df2$value[toy_df2$event=="A"] +
toy_df2$value[toy_df2$event=="B"]
# Calculate mean values for the two events: they will be displayed in the tooltip
toy_df2 <- toy_df2 %>% group_by(event) %>% mutate(mn=round(mean(value),3))
p <- ggplot(data = toy_df2, aes(y = value, x = t, fill=event,
text=paste0("Value:", mn,"<br>Event:", event))) +
geom_polygon()
ggplotly(p, tooltip="text")
#Create Data
library(ggvis)
set.seed(123)
tdat <- data.frame(group = rep(LETTERS[1:2], each = 50),
time = rep(seq(from = as.Date("2010-01-01"), length.out = 50, by = "day"), 2),
val = c(cumsum(rnorm(50)) + 100,
cumsum(rnorm(50)) + 100))
# ggvis Code
# Function for the tooltip
getData <- function(dat){
paste(paste("Time:", as.Date(dat$time/86400000, origin='1970-01-01') ),
paste("Group:", as.character(dat$group)),
paste("Value:", dat$val),
sep = "<br />")
}
#Create Data
library(ggvis)
set.seed(123)
tdat <- data.frame(group = rep(LETTERS[1:2], each = 50),
time = rep(seq(from = as.Date("2010-01-01"), length.out = 50, by = "day"), 2),
val = c(cumsum(rnorm(50)) + 100,
cumsum(rnorm(50)) + 100))
# ggvis Code
# Function for the tooltip
getData <- function(dat){
paste(paste("Time:", as.Date(dat$time/86400000, origin='1970-01-01') ),
paste("Group:", as.character(dat$group)),
paste("Value:", dat$val),
sep = "<br />")
}
# Visualisation
tdat %>% ggvis(~time, ~val, stroke = ~group) %>% layer_lines(strokeWidth := 1) %>%
layer_points(size = 1, fill = ~group, opacity := 0) %>% add_tooltip(getData)
install.packages("ggvis")
#Create Data
library(ggvis)
set.seed(123)
tdat <- data.frame(group = rep(LETTERS[1:2], each = 50),
time = rep(seq(from = as.Date("2010-01-01"), length.out = 50, by = "day"), 2),
val = c(cumsum(rnorm(50)) + 100,
cumsum(rnorm(50)) + 100))
# ggvis Code
# Function for the tooltip
getData <- function(dat){
paste(paste("Time:", as.Date(dat$time/86400000, origin='1970-01-01') ),
paste("Group:", as.character(dat$group)),
paste("Value:", dat$val),
sep = "<br />")
}
# Visualisation
tdat %>% ggvis(~time, ~val, stroke = ~group) %>% layer_lines(strokeWidth := 1) %>%
layer_points(size = 1, fill = ~group, opacity := 0) %>% add_tooltip(getData)
#Create Data
library(ggvis)
set.seed(123)
tdat <- data.frame(group = rep(LETTERS[1:2], each = 50),
time = rep(seq(from = as.Date("2010-01-01"), length.out = 50, by = "day"), 2),
val = c(cumsum(rnorm(50)) + 100,
cumsum(rnorm(50)) + 100))
# ggvis Code
# Function for the tooltip
getData <- function(dat){
paste(paste("Time:", as.Date(dat$time/86400000, origin='1970-01-01') ),
paste("Group:", as.character(dat$group)),
paste("Value:", dat$val),
sep = "<br />")
}
# Visualisation
tdat %>% ggvis(~time, ~val, stroke = ~group) %>% layer_lines(strokeWidth := 1) %>%
layer_points(size = 1, fill = ~group, opacity := 0) %>% add_tooltip(getData)
library(shiny)
library(ggvis)
runApp(list(ui = pageWithSidebar(
div(),
sidebarPanel(
sliderInput("n", "Number of points", min = 1, max = nrow(mtcars),
value = 10, step = 1),
uiOutput("plot_ui")
),
mainPanel(
ggvisOutput("plot"),
tableOutput("mtc_table")
)
)
, server= function(input, output, session) {
# A reactive subset of mtcars
mtc <- reactive({
data = mtcars[1:input$n, ]
data$long = as.character(paste0("A car with ",data$cyl," cylinders and ",data$gear," gears and ",data$carb, " carburators"))
data
})
# A simple visualisation. In shiny apps, need to register observers
# and tell shiny where to put the controls
mtc %>%
ggvis(~wt, ~mpg, key:= ~long) %>%
layer_points(fill = ~factor(long)) %>%
add_tooltip(function(data){
paste0("Wt: ", data$wt, "<br>", "Mpg: ",as.character(data$mpg), "<br>", "String: ", as.character(data$long))
}, "hover") %>%
bind_shiny("plot", "plot_ui")
output$mtc_table <- renderTable({
mtc()[, c("wt", "mpg", "long")]
})
})
)
shiny::runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
type <- c(1:4)
year1 <- c(1, 2, 6, 8)
year2 <- c(1, 2, 6, 8)
year3 <- c(1, 2, 6, 8)
final <- data.frame(type, year1, year2, year3)
final
type <- c(1:4)
depth <- c(1, 2, 6, 8)
area <- c(1, 2, 6, 8)
unit <- c('ft', 'ac', 'ft', 'ac')
final <- data.frame(type, depth, area, unit)
final
final
final[final$unit=='ac']
final
final[final$unit=='ac']
final[final$unit=='ft']
[final$unit=='ft']
final$unit=='ft'
final(final$unit=='ft')
final$unit[final$unit=='ft']
final$unit[final$unit=='ft']
final$area[final$unit=='ft']
final
final$area[final$unit=='ac']
final$new <-final$area[final$unit=='ac']*43560
final
type <- c(1:4)
depth <- c(1, 2, 6, 8)
area <- c(1, 2, 6, 8)
unit <- c('ft', 'ac', 'ft', 'ac')
depth <- c(1, 2, 6, 8)
area <- c(1, 2, 6, 8)
unit <- c('ft', 'ac', 'ft', 'ac')
final <- data.frame(depth, area, unit)
final
final$new <-final$area[final$unit=='ac']*43560
area <- c(1, 2, 3, 8)
depth <- c(1, 2, 3, 8)
area <- c(1, 2, 3, 8)
unit <- c('ft', 'ac', 'ft', 'ac')
final <- data.frame(depth, area, unit)
final
final$new <-final$area[final$unit=='ac']*43560
final
final$area[final$unit=='ac']
final$new <-final$area[final$unit=='ac']*43560
final
final$new <-final$area[final$unit=='ac']*43560
mtcars <- transform(mtcars, mpg=mpg^2)
metcars
mtcars
mtcars <- transform(mtcars, mpg=mpg^2)
mtcars
df$Continent[df$MAKE == 'HOLDEN'] <- 'AUS'
depth <- c(1, 2, 3, 8)
area <- c(1, 2, 3, 8)
unit <- c('ft', 'ac', 'ft', 'ac')
df <- data.frame(depth, area, unit)
df
df$temp <-df[df$unit=='ac']*43560
df$temp <-df$unit[df$unit=='ac']*43560
df$unit[df$unit=='ac']*43560
$area
df$temp <-df$area[df$unit=='ac']*43560
final
df
ifelse(df$unit == 'ac',
df$area*43560)
ifelse(df$unit == 'ac',
df$area*43560,df$area)
df$temp <- ifelse(df$unit == 'ac',
df$area*43560,df$area)
df
depth <- c(1, 2, 3, 8)
area <- c(1, 2, 3, 8)
unit <- c('ft', 'ac', 'ft', 'ac')
df <- data.frame(depth, area, unit)
df
df$temp <- ifelse(df$unit == 'ac',
df$area*43560,df$area)
df
runApp('GitHub/PondCalculator/PondCalc')
unit
unit
## Convert surface area volume to square feet
## Convert input units based on selected input value
depth_area_df$stdarea <-ifelse(depth_area_df$unit == "Acres", depth_area_df$area*43560, depth_area_df$area)
runApp('GitHub/PondCalculator/PondCalc')
## Convert surface area volume to square feet
## Convert input units based on selected input value
depth_area_df$stdarea <-ifelse(depth_area_df$unit == "ac", depth_area_df$area*43560, depth_area_df$area)
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
depth <- c(1, 2, 3, 8)
area <- c(1, 2, 3, 8)
unit <- c('ft', 'ac', 'ft', 'ac')
df <- data.frame(depth, area, unit)
df
df$temp <- ifelse(df$unit == 'ac',
df$area*43560,df$area)
df
df
df$area <- ifelse(df$unit == 'ac',
df$area*43560,df$area)
df
depth <- c(1, 2, 3, 8)
area <- c(1, 2, 3, 8)
unit <- c('ft', 'ac', 'ft', 'ac')
df <- data.frame(depth, area, unit)
df
df$area <- ifelse(df$unit == 'ac',
df$area*43560,df$area)
df
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
width<- 26
length<-18
stocklength <- 20*12
26+18+4
240/48
# NOT RUN {
require(graphics)
f <- function (x, a) (x - a)^2
xmin <- optimize(f, c(0, 1), tol = 0.0001, a = 1/3)
xmin
## See where the function is evaluated:
optimize(function(x) x^2*(print(x)-1), lower = 0, upper = 10)
## "wrong" solution with unlucky interval and piecewise constant f():
f  <- function(x) ifelse(x > -1, ifelse(x < 4, exp(-1/abs(x - 1)), 10), 10)
fp <- function(x) { print(x); f(x) }
plot(f, -2,5, ylim = 0:1, col = 2)
optimize(fp, c(-4, 20))   # doesn't see the minimum
optimize(fp, c(-7, 20))   # ok
shiny::runApp('GitHub/PondCalculator/PondCalc')
shiny::runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
runApp('GitHub/PondCalculator/PondCalc')
